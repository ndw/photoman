#!/usr/bin/perl -- # --*-Perl-*--

use strict;
use English;
use Getopt::Std;
use Image::ExifTool;
use LWP;
use Net::Amazon::S3;
use Net::Amazon::S3::Client;
use POSIX qw(strftime);
use vars qw($opt_D $opt_r $opt_c);

my $usage = "Usage: $0 [-D] [-r] [-c collection] images\n";

die $usage if ! getopts('Drc:p:');

my $DEBUG = $opt_D;
my $REPLACE = $opt_r;
my $collection = $opt_c;

my $ua = new LWP::UserAgent;
$ua->timeout(30);

my %config = ();
open (F, $ENV{'HOME'} . '/.amazon');
while (<F>) {
    chop;
    $config{$1} = $2 if /(\S+?)\s*=\s*(.*?)\s*$/;
}
close (F);

die 'Incomplete configuration\n'
    unless (exists $config{'aws-access-key-id'}
            && exists $config{'aws-secret-access-key'}
            && exists $config{'photoman-bucket'}
            && exists $config{'uri-root'}
            && exists $config{'posthost'} );

my $uri_root = $config{'uri-root'};
my $PHOTOMAN_BUCKET = $config{'photoman-bucket'};
my $posthost = $config{'posthost'};

my $bucket = {};

if (!$DEBUG) {
    my $s3 = Net::Amazon::S3->new(
        'aws_access_key_id'     => $config{'aws-access-key-id'},
        'aws_secret_access_key' => $config{'aws-secret-access-key'},
        'retry'                 => 1
        );

    my $client = Net::Amazon::S3::Client->new( s3 => $s3 );

    # Let's make sure we can find the photoman bucket...
    $bucket = undef;
    foreach my $sbucket ($client->buckets()) {
        if ($sbucket->name() eq $PHOTOMAN_BUCKET) {
            $bucket = $sbucket;
            last;
        }
    }

    die "Cannot find bucket: $PHOTOMAN_BUCKET\n" unless defined $bucket;
    $bucket = $s3->bucket($PHOTOMAN_BUCKET);
}

die "You must specify at least one image.\n" unless @ARGV;

for my $image (@ARGV) {
    my $ext = undef;
    my $contentType = undef;

    if ($image =~ /^.*\.jpe?g$/) {
        $ext = "jpg";
        $contentType = "image/jpeg";
    } elsif ($image =~ /^.*\.gif$/) {
        $ext = "gif";
        $contentType = "image/gif";
    } else {
        warn "Cannot handle image: $image\n";
        next;
    }

    my $tmpfile = "/tmp/photoman.$$.$ext";

    my $exif = new Image::ExifTool;
    $exif->Options(IgnoreMinorErrors => '1');
    $exif->ExtractInfo($image);

    my $width = $exif->GetValue('ImageWidth');
    my $height = $exif->GetValue('ImageHeight');

    my $rot = "";
    my $orient = $exif->GetValue("Orientation");

    if ($orient eq 'Rotate 90 CW') {
        $rot = " -rotate 90";
    } elsif ($orient eq 'Rotate 270 CW' || $orient eq 'Rotate 90 CCW') {
        $rot = " -rotate 270";
    } elsif ($orient eq 'Rotate 180') {
        $rot = " -rotate 180";
    }

    my $rc = "some defined value";

    print "$image\n";

    die "You meant to include the path, surely?\n"
        unless $image =~ /\/?(.*?)\/([^\/]+)$/;

    my $path = "$uri_root/$1";
    my $filename = $2;

    my %sizes = ("64" => { "crop" => "square",
                           "path" => "$path/64" },
                 "150" => { "crop" => "height",
                            "path" => "$path/150" },
                 "500" => { "path" => "$path/500" },
                 "1024" => { "path" => "$path" });

    foreach my $size (sort { $a <=> $b } keys %sizes) {
        my $maxwidth = $size;
        my $maxheight = $size;
        my $crop = "";

        # do height first because sometimes that's all we care about...
        my $hscale = $maxheight / $height;
        my $newwidth = int($width * $hscale);
        my $newheight = int($height * $hscale);

        if ($sizes{$size}->{'crop'} eq 'height') {
            # we're done
        } elsif ($sizes{$size}->{'crop'} eq 'width') {
            my $wscale = $maxwidth / $width;
            $newwidth = int($width * $wscale);
            $newheight = int($height * $wscale);
        } elsif ($sizes{$size}->{'crop'} eq 'square') {
            if ($width != $height) { # Crop to square
                if ($width > $height) {
                    $newwidth = $height;
                    $newheight = $height;
                    $crop = int(($width - $height) / 2);
                    $crop = "-crop ${newwidth}x${newheight}+${crop}+0";
                } else {
                    $newwidth = $width;
                    $newheight = $width;
                    $crop = int(($height - $width) / 2);
                    $crop = "-crop ${newwidth}x${newheight}+0+${crop}";
                }
                $newwidth = $size;
                $newheight = $size;
            }
        } else {
            if ($newwidth > $maxwidth) {
                my $wscale = $maxwidth / $width;
                $newwidth = int($width * $wscale);
                $newheight = int($height * $wscale);
            }
        }

        if ($newwidth > $width || $newheight > $height) {
            $newwidth = $width;
            $newheight = $height;
        }

        my $s3path = $sizes{$size}->{'path'} . "/" . $filename;

        my $convert = "convert $crop$rot -geometry ${newwidth}x${newheight} \"$image\" \"$tmpfile\"";

        if ($contentType eq 'image/gif') {
            # this might be an animated gif and they need to be cropped
            # with special ImageMagick options
            $convert = "convert \"$image\" -coalesce -repage 0x0 $crop$rot +repage -geometry ${newwidth}x${newheight} \"$tmpfile\"";
        }

        print "\tScale:  ($width,$height)$rot => ($newwidth,$newheight)\n";

        my $exists = $DEBUG || defined($bucket->get_key($s3path));

        if ($DEBUG) {
            # print "$convert\n";
        } else {
            system $convert unless ($exists && !$REPLACE);
        }

        if ($exists && !$REPLACE) {
            print "\t\tSkipping upload, key exists\n";
        } else {
            print "\tUpload: $s3path\n";
            $rc = upload($s3path, $tmpfile, $contentType);
            die unless $rc;
        }
    }

    print "\tExtract EXIF metadata\n";
    system("exiftool -X $image > $tmpfile")
        unless $DEBUG;
    my $s3path = $path . "/" . $filename;
    $s3path =~ s/\.jpg$/\.xml/;
    $s3path =~ s/\.gif$/\.xml/;
    print "\tUpload: $s3path\n";

    open (F, $tmpfile);
    read (F, $_, -s $tmpfile);
    close (F);

    post($_, "application/xml", "/" . $s3path, $collection) unless $DEBUG;

    #$rc = upload($s3path, $tmpfile, "application/xml");
    #die unless $rc;
}

# ================================================================================

sub upload {
    my $key = shift;
    my $tmpfile = shift;
    my $contentType = shift;

    return 1 if $DEBUG;

    my $exists = $bucket->get_key($key);

    if ($exists && !$REPLACE) {
        warn "\t\tSkipping upload, key exists\n";
        return 1;
    }

    return $bucket->add_key_filename($key, $tmpfile,
                                     { 'content_type' => $contentType,
                                       'acl_short' => 'public-read'
                                     });
}

# ================================================================================

sub post {
    my $data = shift;
    my $type = shift;
    my $uri = shift;
    my $collection = shift;
    my $skip = shift;
    my $method = "POST";
    my $username = undef;
    my $password = undef;

    my $posturi  = "http://$posthost/upload.xqy?media=$type&uri=$uri";
    $posturi .= "&collection=$collection" if defined($collection);
    $posturi .= "&skip=true" if defined($skip);

    if ($DEBUG) {
        print STDERR "POST $posturi\n";
        return 200;
    }

    my $req = new HTTP::Request($method => $posturi);

    $req->content($data);
    $req->header("Content-Type" => $type);

    my $resp = $ua->request($req);

    if ($resp->code() == 401 && defined($username) && defined($password)) {
        #print "Authentication required. Trying again with specified credentials.\n";
        my $host = $posturi;
        $host =~ s/^.*?\/([^\/]+).*?$/$1/;
        my $realm = scalar($resp->header('WWW-Authenticate'));
        if ($realm =~ /realm=[\'\"]/) {
            $realm =~ s/^.*?realm=([\'\"])(.*?)\1.*$/$2/;
        } else {
            $realm =~ s/^.*?realm=(.*?)$/$1/;
        }
        # print "Auth: $host, $realm, $username, $password\n";
        $ua->credentials($host, $realm, $username => $password);
        $resp = $ua->request($req);
    }

    print $resp->code(), " ", $resp->content(), "\n"
        unless $resp->code() == 200;

    return $resp->code();
}

sub photodate {
    my $image = shift;

    my $exif = new Image::ExifTool;
    $exif->Options(IgnoreMinorErrors => '1');
    $exif->ExtractInfo($image);

    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks)
        = stat($image);

    # Let's see if we can figure out the date/time this picture was taken
    # Use the current date/time if we can't find one in the EXIF
    my @dto_list = ( $exif->GetValue("CreateDate", 'ValueConv'),
                     $exif->GetValue("DateCreated", 'ValueConv'),
                     $exif->GetValue("DateTimeOriginal", 'ValueConv'),
                     strftime("%Y:%m:%d %H:%M:%S", localtime($mtime)) );
    my $dto = $dto_list[0];

    die "Cannot parse date/time: $dto\n"
        unless $dto =~ /^(\d\d\d\d):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)(\.(\d+))?$/;

    return $dto;
}
