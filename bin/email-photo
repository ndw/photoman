#!/usr/bin/perl -- # --*-Perl-*--

use strict;
use English;
use MIME::Parser;
use Image::ExifTool;
use Cwd;

################################################################################
#
# NOTE: This can't possibly work until you edit it to suit your local
# configuration. I run it with a procmail rule.
#
################################################################################

my $ROOT="/tmp";
my $UPLOAD="/MarkLogic/photoman2/bin/upload-photo";

chdir($ROOT) || abort("Failed to chdir to $ROOT");

my $parser = new MIME::Parser;
$parser->output_under("/tmp");

my $entity = $parser->parse(\*STDIN);

report("parsed entity");

#open (F, ">/tmp/mime-skeleton");
#$entity->dump_skeleton(\*F);
#close (F);

# Ok, I expect the inbound message to be a multipart mixed with
# a multipart/alternative part and an image/jpeg part...

abort("Not multipart/mixed?")
    unless $entity->mime_type() eq 'multipart/mixed';

my @parts = $entity->parts();

abort("Wrong number of parts?")
    unless $#parts = 1;

my $part1 = $entity->parts(0);
my $part2 = $entity->parts(1);

if ($part1->mime_type() eq 'multipart/alternative') {
    abort("No image part, or wrong type")
        unless $part2->mime_type() eq 'image/jpeg';
    process($entity, $part1, $part2);
} elsif ($part1->mime_type() eq 'image/jpeg') {
    abort("No alternative part")
        unless $part2->mime_type() eq 'multipart/alternative';
    process($entity, $part2, $part1);
} else {
    abort("Didn't find correct parts");
}

exit 0;

sub process {
    my $entity = shift;
    my $altpart = shift;
    my $imgpart = shift;

    report("processing entity");

    my $imgbody = $imgpart->bodyhandle();
    abort("No path to image?") unless $imgbody->path();

    my $exif = new Image::ExifTool;
    $exif->Options(IgnoreMinorErrors => '1');
    $exif->ExtractInfo($imgbody->path());

    my $head = $entity->head();
    my $subject = $head->get("Subject");
    chop($subject);

    report("subject: $subject");

    $exif->SetNewValue('Title', $subject);

    my $txtpart = undef;
    foreach my $part ($altpart->parts()) {
        if ($part->mime_type() eq 'text/plain') {
            abort("Multiple plain parts?")
                if defined($txtpart);
            $txtpart = $part;
        }
    }

    abort("No plain part?") unless defined($txtpart);

    my $collection = undef;
    my $body = $txtpart->bodyhandle();
    my $IO = $body->open("r");
    while (defined($_ = $IO->getline())) {
        chop;
        if (/^tag:\s*/i) {
            $_ = $POSTMATCH;
            my @tags = split(/,\s*/, $_);

            report("tag: " . join(", ", @tags));

            $exif->SetNewValue('Subject', \@tags);
            $exif->SetNewValue('Keywords', \@tags);
        }

        if (/^set:\s*/i) {
            $_ = $POSTMATCH;
            s/\s+//sg;

            $collection = $_;

            report("set: ", $collection);
        }

        if (/^loc:\s*/i || /^location:\s*/) {
            $_ = $POSTMATCH;
            my @places = split(/,\s*/, $_);
            my $city = shift @places;
            my $province = shift @places;
            my $country = shift @places;
            if (!defined($country)) {
                $country = $province;
                $province = undef;
            }

            report("loc: " . $country . "|" . $province . "|" . $city);

            $exif->SetNewValue("Country-PrimaryLocationName", $country)
                if defined($country);
            $exif->SetNewValue("Province-State", $province)
                if defined($province);
            $exif->SetNewValue("City", $city)
                if defined($city);
        }
    }
    $IO->close();

    my $dir = $exif->GetValue("DateTimeOriginal");

    if (defined($dir)) {
        report("DateTimeOriginal: " . $dir);
    } else {
        my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time());
        $dir = sprintf("%04d:%02d:%02d %02d:%02d:%02d",
                       $year+1900, $mon+1, $mday, $hour, $min, $sec);
        report("No DateTimeOriginal: " . $dir);
    }

    $dir =~ s/\s.+$//;
    $dir =~ s/:/\//g;

    if (! -d $dir) {
        system("mkdir -p $dir") && abort("Unable to mkdir $dir");
    }

    report("Updating EXIF");
    $exif->WriteInfo($imgbody->path());

    my $fn = $imgbody->path();
    $fn =~ s/^.*(\/[^\/]+)$/$1/;
    $fn = $dir . $fn;

    report("cp " . $imgbody->path() . " $fn");
    system("cp " . $imgbody->path() . " $fn")
        && abort("Unable to copy image to $fn");

    my $uargs = defined($collection) ? "-c \"$collection\" $fn" : $fn;
    system ("$UPLOAD $uargs >> /tmp/email-photo.log 2>&1") && "Upload failed: $fn\n";
}

sub abort {
    my $msg = shift;
    open (F, ">>/tmp/email-photo.log");
    print F "$msg\n";
    close (F);
    exit (1);
}

sub report {
    my $msg = shift;
    open (F, ">>/tmp/email-photo.log");
    print F "$msg\n";
    close (F);
}
